#!/usr/bin/perl
#
# Copyright © 1998      Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
# Copyright © 2005-2008 Ryan Murray <rmurray@debian.org>
# Copyright © 2008      Roger Leigh <rleigh@debian.org
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#
#######################################################################

package main;

use strict;
use warnings;

use POSIX;
use FileHandle;
use GDBM_File;
use MLDBM qw(GDBM_File Storable);
use Sbuild qw(isin usage_error);
use WannaBuild::Conf;
use Sbuild::Sysconfig;
use Sbuild::DBInfo;
use WannaBuild::Options;

sub process ();
sub add_packages ($@);
sub add_one_building ($$);
sub add_one_attempted ($$);
sub add_one_built ($$);
sub add_one_uploaded ($$);
sub add_one_failed ($$);
sub add_one_notforus ($$);
sub add_one_needsbuild ($$);
sub set_one_binnmu ($$);
sub set_one_buildpri ($$$);
sub add_one_depwait ($$);
sub parse_sources ($);
sub parse_packages ();
sub pretend_avail (@);
sub check_dep_wait ($$);
sub parse_quinn_diff ($);
sub send_reupload_mail ($$$$$);
sub sort_list_func ();
sub list_packages ($);
sub info_packages (@);
sub forget_packages (@);
sub forget_users (@);
sub lock_db ($);
sub unlock_db ($);
sub create_maintlock ();
sub remove_maintlock ();
sub waitfor_maintlock ();
sub read_db ($);
sub check_entry ($);
sub write_db ($);
sub change_state ($$;$);
sub open_other_db ($);
sub log_ta ($$;$);
sub dist_cmp ($$);
sub send_mail ($$$);
sub db_filename ($);
sub parse_deplist ($;$);
sub parse_srcdeplist ($$$);
sub build_deplist ($);
sub clean_db ();
sub get_unsatisfied_dep ($$$$);
sub auto_dep_wait ($$);
sub pkg_version_eq ($$);

our ($mail_logs, $curr_date, %db, %otherdb, %otherdb_lock, %prioval,
     %sectval, %catval, $short_date, %new_vers, %merge_binsrc, %merge_srcvers);

my $conf = WannaBuild::Conf->new();
exit 1 if !defined($conf);
my $options = WannaBuild::Options->new($conf);
exit 1 if !defined($options);

# Temporarily set globals from conf object:
$mail_logs = "";
my @curr_time = gmtime();
+$curr_date = strftime("%Y %b %d %H:%M:%S",@curr_time);
+$short_date = strftime("%m/%d/%y",@curr_time);

# Undefined: %db %new_vers %merge_srcvers

# global vars
$ENV{'PATH'} = "/bin:/usr/bin:/usr/local/bin";
$| = 1;

# map program invocation names to operation modes
my %prognames = ( "uploaded-build"  => "set-uploaded",
		  "failed-build"    => "set-failed",
		  "no-build"		=> "set-not-for-us",
		  "give-back-build" => "set-needs-build",
		  "dep-wait-build"  => "set-dep-wait",
		  "forget-build"	=> "forget",
		  "merge-quinn"		=> "merge-quinn",
		  "merge-packages"  => "merge-packages",
		  "merge-sources"   => "merge-sources",
		  "build-info"		=> "info" );


my $progname;
($progname = $0) =~ s,.*/,,;
if ($prognames{$progname}) {
    $conf->set('DB_OPERATION',  $prognames{$progname});
}
elsif ($progname =~ /^list-(.*)$/) {
    $conf->set('DB_OPERATION', 'list');
    $conf->set('DB_LIST_STATE', ($1 eq "all") ? "" : $1);
}

$conf->set('DB_OPERATION', $conf->get('DB_CATEGORY') ? "set-failed" : "set-building")
    if !$conf->get('DB_OPERATION'); # default operation
$conf->set('DB_LIST_ORDER', $conf->get('DB_LIST_STATE') eq "failed" ? 'fPcpsn' : 'PScpsn')
    if (!$conf->get('DB_LIST_ORDER') &&
	(defined($conf->get('DB_LIST_STATE')) && $conf->get('DB_LIST_STATE')));
$conf->set('DISTRIBUTION', 'unstable')
    if !defined($conf->get('DISTRIBUTION'));

die "Bad distribution '" . $conf->get('DISTRIBUTION') . "'\n"
    if !isin($conf->get('DISTRIBUTION'), keys %{$conf->get('DB_DISTRIBUTIONS')});

if ($conf->get('VERBOSE')) {
    print "wanna-build (Debian sbuild) $Sbuild::Sysconfig::version ($Sbuild::Sysconfig::release_date) on " . $conf->get('HOSTNAME') . "\n";
    print "Using database " . $conf->get('DB_BASE_NAME') . '/' . $conf->get('DISTRIBUTION') . "\n"
}

if (!@ARGV && !isin( $conf->get('DB_OPERATION'), qw(list merge-quinn merge-partial-quinn import export
				  merge-packages manual-edit maintlock-create
				  merge-sources maintlock-remove clean-db))) {
    usage_error("wanna-build", "No packages given.");
}

if (!$conf->get('DB_FAIL_REASON')) {
    if ($conf->get('DB_OPERATION') eq "set-failed" && !$conf->get('DB_CATEGORY')) {
	print "Enter reason for failing (end with '.' alone on ".
	    "its line):\n";
	my $log = "";
	my $line;
	while(!eof(STDIN)) {
	    $line = <STDIN>;
	    last if $line eq ".\n";
	    $line = ".\n" if $line eq "\n";
	    $log .= $line;
	}
	chomp($log);
	$conf->set('DB_FAIL_REASON', $log);
    } elsif ($conf->get('DB_OPERATION') eq "set-dep-wait") {
	print "Enter dependencies (one line):\n";
	my $line;
	while( !$line && !eof(STDIN) ) {
	    chomp( $line = <STDIN> );
	}
	die "No dependencies given\n" if !$line;
	$conf->set('DB_FAIL_REASON'. $line);
    } elsif ($conf->get('DB_OPERATION') eq "set-binary-nmu" and $conf->get('DB_BIN_NMU_VERSION') > 0) {
	print "Enter changelog entry (one line):\n";
	my $line;
	while( !$line && !eof(STDIN) ) {
	    chomp( $line = <STDIN> );
	}
	die "No changelog entry given\n" if !$line;
	$conf->set('DB_FAIL_REASON', $line);
    }
}
if ($conf->get('DB_OPERATION') eq "maintlock-create") {
    create_maintlock();
    exit 0;
}
if ($conf->get('DB_OPERATION') eq "maintlock-remove") {
    remove_maintlock();
    exit 0;
}
waitfor_maintlock() if $conf->get('DB_OPERATION') !~ /^(?:merge-|clean-db$)/;

if (!-f db_filename( $conf->get('DISTRIBUTION') ) && !$conf->get('DB_CREATE')) {
    die "Database for " . $conf->get('DISTRIBUTION') . " doesn't exist\n";
}
lock_db( $conf->get('DISTRIBUTION') );
END {
    untie %db;
    unlock_db($conf->get('DISTRIBUTION'));
    foreach (keys %{$conf->get('DB_DISTRIBUTIONS')}) {
	untie %{$otherdb{$_}} if tied(%{$otherdb{$_}});
	unlock_db( $_ ) if $otherdb_lock{$_};
    }
}

tie %db, 'MLDBM', db_filename( $conf->get('DISTRIBUTION') ), GDBM_WRCREAT, 0664
    or die "FATAL: Cannot open database\n";

process();

if ($mail_logs &&
    defined($conf->get('DB_LOG_MAIL')) && $conf->get('DB_LOG_MAIL')) {
    send_mail( $conf->get('DB_LOG_MAIL'),
	       "wanna-build " . $conf->get('DISTRIBUTION') .
	       " state changes $curr_date",
	       "State changes at $curr_date for distribution ".
	       $conf->get('DISTRIBUTION') . ":\n\n$mail_logs\n" );
}

exit 0;


sub process () {

  SWITCH: foreach ($conf->get('DB_OPERATION')) {
      /^set-(.+)/ && do {
	  add_packages( $1, @ARGV );
	  last SWITCH;
      };
      /^list/ && do {
	  list_packages($conf->get('DB_LIST_STATE'));
	  last SWITCH;
      };
      /^info/ && do {
	  info_packages( @ARGV );
	  last SWITCH;
      };
      /^forget-user/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  forget_users( @ARGV );
	  last SWITCH;
      };
      /^forget/ && do {
	  forget_packages( @ARGV );
	  last SWITCH;
      };
      /^merge-partial-quinn/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  parse_quinn_diff(1);
	  last SWITCH;
      };
      /^merge-quinn/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  parse_quinn_diff(0);
	  last SWITCH;
      };
      /^merge-packages/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  parse_packages();
	  last SWITCH;
      };
      /^merge-sources/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  parse_sources(0);
	  last SWITCH;
      };
      /^pretend-avail/ && do {
	  pretend_avail( @ARGV );
	  last SWITCH;
      };
      /^merge-all/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  my @ARGS = @ARGV;
	  @ARGV = ( $ARGS[0] );
	  my $pkgs = parse_packages();
	  @ARGV = ( $ARGS[1] );
	  parse_quinn_diff(0);
	  @ARGV = ( $ARGS[2] );
	  my $build_deps = parse_sources(1);
	  auto_dep_wait( $build_deps, $pkgs );
	  clean_db();
	  last SWITCH;
      };
      /^import/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  %db = (); # clear all current contents
	  read_db($conf->get('DB_IMPORT_FILE'));
	  last SWITCH;
      };
      /^export/ && do {
	  write_db($conf->get('DB_EXPORT_FILE'));
	  last SWITCH;
      };
      /^manual-edit/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  my $tmpfile_pattern = "/tmp/wanna-build-" . $conf->get('DISTRIBUTION') . ".$$-";
	  my ($tmpfile, $i);
	  for( $i = 0;; ++$i ) {
	      $tmpfile = $tmpfile_pattern . $i;
	      last if ! -e $tmpfile;
	  }
	  write_db( $tmpfile );
	  my $editor = $ENV{'VISUAL'} ||
	      "/usr/bin/sensible-editor";
	  system "$editor $tmpfile";
	  %db = (); # clear all current contents
	  read_db( $tmpfile );
	  unlink( $tmpfile );
	  last SWITCH;
      };
      /^clean-db/ && do {
	  die "This operation is restricted to admin users\n"
	      if (defined @{$conf->get('DB_ADMIN_USERS')} and
		  !isin( $conf->get('USERNAME'), @{$conf->get('DB_ADMIN_USERS')}));
	  clean_db();
	  last SWITCH;
      };

      die "Unexpected operation mode " . $conf->get('DB_OPERATION') . "\n";
  }
    if (not -t and $conf->get('DB_USER') =~ /-/) {
	my $userinfo = $db{'_userinfo'};
	$userinfo = {} if (!defined($userinfo));

	my $ui = $userinfo->{$conf->get('DB_USER')};
	$ui = {} if (!defined($ui));

	$ui->{'Last-Seen'} = $curr_date;
	$ui->{'User'} = $conf->get('DB_USER');

	$userinfo->{$conf->get('DB_USER')} = $ui;

	$db{'_userinfo'} = $userinfo;
    }

}

sub add_packages ($@) {
    my $newstate = shift;
    my( $package, $name, $version, $ok, $reason );

    foreach $package (@_) {
	$package =~ s,^.*/,,; # strip path
	$package =~ s/\.(dsc|diff\.gz|tar\.gz|deb)$//; # strip extension
	$package =~ s/_[a-zA-Z\d-]+\.changes$//; # strip extension
	if ($package =~ /^([\w\d.+-]+)_([\w\d:.+~-]+)/) {
	    ($name,$version) = ($1,$2);
	}
	else {
	    warn "$package: can't extract package name and version ".
		"(bad format)\n";
	    next;
	}

	if ($conf->get('DB_OPERATION') eq "set-building") {
	    add_one_building( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-built") {
	    add_one_built( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-attempted") {
	    add_one_attempted( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-uploaded") {
	    add_one_uploaded( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-failed") {
	    add_one_failed( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-not-for-us") {
	    add_one_notforus( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-needs-build") {
	    add_one_needsbuild( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-dep-wait") {
	    add_one_depwait( $name, $version );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-build-priority") {
	    set_one_buildpri( $name, $version, 'BuildPri' );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-permanent-build-priority") {
	    set_one_buildpri( $name, $version, 'PermBuildPri' );
	}
	elsif ($conf->get('DB_OPERATION') eq "set-binary-nmu") {
	    set_one_binnmu( $name, $version );
	}
    }
}

sub add_one_building ($$) {
    my $name = shift;
    my $version = shift;
    my( $ok, $reason );

    $ok = 1;
    my $pkg = $db{$name};
    if (defined($pkg)) {
	if ($pkg->{'State'} eq "Not-For-Us") {
	    $ok = 0;
	    $reason = "not suitable for this architecture";
	}
	elsif ($pkg->{'State'} =~ /^Dep-Wait/) {
	    $ok = 0;
	    $reason = "not all source dependencies available yet";
	}
	elsif ($pkg->{'State'} eq "Uploaded" &&
	       (version_lesseq($version, $pkg->{'Version'}))) {
	    $ok = 0;
	    $reason = "already uploaded by $pkg->{'Builder'}";
	    $reason .= " (in newer version $pkg->{'Version'})"
		if !version_eq($pkg, $version);
	}
	elsif ($pkg->{'State'} eq "Installed" &&
	       version_less($version,$pkg->{'Version'})) {
	    if ($conf->get('DB_OVERRIDE')) {
		print "$name: Warning: newer version $pkg->{'Version'} ".
		    "already installed, but overridden.\n";
	    }
	    else {
		$ok = 0;
		$reason = "newer version $pkg->{'Version'} already in ".
		    "archive; doesn't need rebuilding";
		print "$name: Note: If the following is due to an epoch ",
		" change, use --override\n";
	    }
	}
	elsif ($pkg->{'State'} eq "Installed" &&
	       pkg_version_eq($pkg,$version)) {
	    $ok = 0;
	    $reason = "is up-to-date in the archive; doesn't need rebuilding";
	}
	elsif ($pkg->{'State'} eq "Needs-Build" &&
	       version_less($version,$pkg->{'Version'})) {
	    if ($conf->get('DB_OVERRIDE')) {
		print "$name: Warning: newer version $pkg->{'Version'} ".
		    "needs building, but overridden.";
	    }
	    else {
		$ok = 0;
		$reason = "newer version $pkg->{'Version'} needs building, ".
		    "not $version";
	    }
	}
	elsif (isin($pkg->{'State'},qw(Building Built Build-Attempted))) {
	    if (version_less($pkg->{'Version'},$version)) {
		print "$name: Warning: Older version $pkg->{'Version'} ",
		"is being built by $pkg->{'Builder'}\n";
		if ($pkg->{'Builder'} ne $conf->get('DB_USER')) {
		    send_mail( $pkg->{'Builder'},
			       "package takeover in newer version",
			       "You are building package '$name' in ".
			       "version $version\n".
			       "(as far as I'm informed).\n".
			       $conf->get('DB_USER') . " now has taken the newer ".
			       "version $version for building.".
			       "You can abort the build if you like.\n" );
		}
	    }
	    else {
		if ($conf->get('DB_OVERRIDE')) {
		    print "User $pkg->{'Builder'} had already ",
		    "taken the following package,\n",
		    "but overriding this as you request:\n";
		    send_mail( $pkg->{'Builder'}, "package takeover",
			       "The package '$name' (version $version) that ".
			       "was locked by you\n".
			       "has been taken over by " . $conf->get('DB_USER') . "\n" );
		}
		elsif ($pkg->{'Builder'} eq $conf->get('DB_USER')) {
		    print "$name: Note: already taken by you.\n";
		    print "$name: ok\n" if $conf->get('VERBOSE');
		    return;
		}
		else {
		    $ok = 0;
		    $reason = "already taken by $pkg->{'Builder'}";
		    $reason .= " (in newer version $pkg->{'Version'})"
			if !version_eq($pkg->{'Version'}, $version);
		}
	    }
	}
	elsif ($pkg->{'State'} =~ /^Failed/ &&
	       pkg_version_eq($pkg, $version)) {
	    if ($conf->get('DB_OVERRIDE')) {
		print "The following package previously failed ",
		"(by $pkg->{'Builder'})\n",
		"but overriding this as you request:\n";
		send_mail( $pkg->{'Builder'}, "failed package takeover",
			   "The package '$name' (version $version) that ".
			   "is locked by you\n".
			   "and has failed previously has been taken over ".
			   "by " . $conf->get('DB_USER') . "\n" )
		    if $pkg->{'Builder'} ne $conf->get('DB_USER');
	    }
	    else {
		$ok = 0;
		$reason = "build of $version failed previously:\n    ";
		$reason .= join( "\n    ", split( "\n", $pkg->{'Failed'} ));
		$reason .= "\nalso the package doesn't need builing"
		    if $pkg->{'State'} eq 'Failed-Removed';
	    }
	}
    }
    if ($ok) {
	my $ok = 'ok';
	if ($pkg->{'Binary-NMU-Version'}) {
	    print "$name: Warning: needs binary NMU $pkg->{'Binary-NMU-Version'}\n" .
		"$pkg->{'Binary-NMU-Changelog'}\n";
	    $ok = 'aok';
	} else {
	    print "$name: Warning: Previous version failed!\n"
		if $pkg->{'Previous-State'} =~ /^Failed/ ||
		$pkg->{'State'} =~ /^Failed/;
	}
	change_state( \$pkg, 'Building' );
	$pkg->{'Package'} = $name;
	$pkg->{'Version'} = $version;
	$pkg->{'Builder'} = $conf->get('DB_USER');
	log_ta( $pkg, "--take" );
	$db{$name} = $pkg;
	print "$name: $ok\n" if $conf->get('VERBOSE');
    }
    else {
	print "$name: NOT OK!\n  $reason\n";
    }
}

sub add_one_attempted ($$) {
	my $name = shift;
	my $version = shift;
	my $pkg = $db{$name};

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}

	if ($pkg->{'State'} ne "Building" ) {
		print "$name: not taken for building (state is $pkg->{'State'}). ",
			  "Skipping.\n";
		return;
	}
	if ($pkg->{'Builder'} ne $conf->get('USERNAME')) {
		print "$name: not taken by you, but by $pkg->{'Builder'}. Skipping.\n";
		return;
	}
	elsif ( !pkg_version_eq($pkg, $version) ) {
		print "$name: version mismatch ".
			  "$(pkg->{'Version'} ".
			  "by $pkg->{'Builder'})\n";
		return;
	}

	change_state( \$pkg, 'Build-Attempted' );
	log_ta( $pkg, "--attempted" );
	$db{$name} = $pkg;
	print "$name: registered as uploaded\n" if $conf->get('VERBOSE');
}

sub add_one_built ($$) {
	my $name = shift;
	my $version = shift;
	my $pkg = $db{$name};

	if (!defined($pkg)) {
		print "$name: not registered yet.\n";
		return;
	}

	if ($pkg->{'State'} ne "Building" ) {
		print "$name: not taken for building (state is $pkg->{'State'}). ",
			  "Skipping.\n";
		return;
	}
	if ($pkg->{'Builder'} ne $conf->get('USERNAME')) {
		print "$name: not taken by you, but by $pkg->{'Builder'}. Skipping.\n";
		return;
	}
	elsif ( !pkg_version_eq($pkg, $version) ) {
		print "$name: version mismatch ".
			  "$(pkg->{'Version'} ".
			  "by $pkg->{'Builder'})\n";
		return;
	}
	change_state( \$pkg, 'Built' );
	log_ta( $pkg, "--built" );
	$db{$name} = $pkg;
	print "$name: registered as built\n" if $conf->get('VERBOSE');
}

sub add_one_uploaded ($$) {
    my $name = shift;
    my $version = shift;
    my $pkg = $db{$name};

    if (!defined($pkg)) {
	print "$name: not registered yet.\n";
	return;
    }

    if ($pkg->{'State'} eq "Uploaded" &&
	pkg_version_eq($pkg,$version)) {
	print "$name: already uploaded\n";
	return;
    }
    if (!isin( $pkg->{'State'}, qw(Building Built Build-Attempted))) {
	print "$name: not taken for building (state is $pkg->{'State'}). ",
	"Skipping.\n";
	return;
    }
    if ($pkg->{'Builder'} ne $conf->get('DB_USER')) {
	print "$name: not taken by you, but by $pkg->{'Builder'}. Skipping.\n";
	return;
    }
    # strip epoch -- buildd-uploader used to go based on the filename.
    # (to remove at some point)
    my $pkgver;
    ($pkgver = $pkg->{'Version'}) =~ s/^\d+://;
    $version =~ s/^\d+://; # for command line use
    if ($pkg->{'Binary-NMU-Version'} ) {
	my $nmuver = binNMU_version($pkgver, $pkg->{'Binary-NMU-Version'});
	if (!version_eq( $nmuver, $version )) {
	    print "$name: version mismatch ($nmuver registered). ",
	    "Skipping.\n";
	    return;
	}
    } elsif (!version_eq($pkgver, $version)) {
	print "$name: version mismatch ($pkg->{'Version'} registered). ",
	"Skipping.\n";
	return;
    }

    change_state( \$pkg, 'Uploaded' );
    log_ta( $pkg, "--uploaded" );
    $db{$name} = $pkg;
    print "$name: registered as uploaded\n" if $conf->get('VERBOSE');
}

sub add_one_failed ($$) {
    my $name = shift;
    my $version = shift;
    my ($state, $cat);
    my $pkg = $db{$name};

    if (!defined($pkg)) {
	print "$name: not registered yet.\n";
	return;
    }
    $state = $pkg->{'State'};

    if ($state eq "Not-For-Us") {
	print "$name: not suitable for this architecture anyway. Skipping.\n";
	return;
    }
    elsif ($state eq "Failed-Removed") {
	print "$name: failed previously and doesn't need building. Skipping.\n";
	return;
    }
    elsif ($state eq "Installed") {
	print "$name: Is already installed in archive. Skipping.\n";
	return;
    }
    elsif ($pkg->{'Builder'} &&
	   (($conf->get('DB_USER') ne $pkg->{'Builder'}) &&
	    !($pkg->{'Builder'} =~ /^(\w+)-\w+/ && $1 eq $conf->get('DB_USER')))) {
	print "$name: not taken by you, but by ".
	    "$pkg->{'Builder'}. Skipping.\n";
	return;
    }
    elsif ( !pkg_version_eq($pkg, $version) ) {
	print "$name: version mismatch ".
	    "$(pkg->{'Version'} ".
	    "by $pkg->{'Builder'})\n";
	return;
    }

    $cat = $conf->get('DB_CATEGORY');
    if (!$cat && $conf->get('DB_FAIL_REASON') =~ /^\[([^\]]+)\]/) {
	$cat = $1;
	$cat = category($cat);
	$cat = "" if !defined($cat);
	my $fail_reason = $conf->get('DB_FAIL_REASON');
	$fail_reason =~ s/^\[[^\]]+\][ \t]*\n*//;
	$conf->set('DB_FAIL_REASON', $fail_reason);
    }

    if ($state eq "Needs-Build") {
	print "$name: Warning: not registered for building previously, ".
	    "but processing anyway.\n";
    }
    elsif ($state eq "Uploaded") {
	print "$name: Warning: marked as uploaded previously, ".
	    "but processing anyway.\n";
    }
    elsif ($state eq "Dep-Wait") {
	print "$name: Warning: marked as waiting for dependencies, ".
	    "but processing anyway.\n";
    }
    elsif ($state eq "Failed") {
	print "$name: already registered as failed; will append new message\n"
	    if $conf->get('DB_FAIL_REASON');
	print "$name: already registered as failed; changing category\n"
	    if $cat;
    }

    if (($cat eq "reminder-sent" || $cat eq "nmu-offered") &&
	exists $pkg->{'Failed-Category'} &&
	$pkg->{'Failed-Category'} ne $cat) {
	(my $action = $cat) =~ s/-/ /;
	$conf->set('DB_FAIL_REASON',
		   $conf->get('DB_FAIL_REASON') . "\n$short_date: $action");
    }

    change_state( \$pkg, 'Failed' );
    $pkg->{'Builder'} = $conf->get('DB_USER');
    $pkg->{'Failed'} .= "\n" if $pkg->{'Failed'};
    $pkg->{'Failed'} .= $conf->get('DB_FAIL_REASON');
    $pkg->{'Failed-Category'} = $cat if $cat;
    if (defined $pkg->{'PermBuildPri'}) {
	$pkg->{'BuildPri'} = $pkg->{'PermBuildPri'};
    } else {
	delete $pkg->{'BuildPri'};
    }
    log_ta( $pkg, "--failed" );
    $db{$name} = $pkg;
    print "$name: registered as failed\n" if $conf->get('VERBOSE');
}

sub add_one_notforus ($$) {
    my $name = shift;
    my $version = shift;
    my $pkg = $db{$name};

    if ($pkg->{'State'} eq 'Not-For-Us') {
	# reset Not-For-Us state in case it's called twice; this is
	# the only way to get a package out of this state...
	# There is no really good state in which such packages should
	# be put :-( So use Failed for now.
	change_state( \$pkg, 'Failed' );
	$pkg->{'Package'} = $name;
	$pkg->{'Failed'} = "Was Not-For-Us previously";
	delete $pkg->{'Builder'};
	delete $pkg->{'Depends'};
	log_ta( $pkg, "--no-build(rev)" );
	print "$name: now not unsuitable anymore\n";

	send_mail( $conf->get('DB_NOTFORUS_MAINTAINER_EMAIL'),
		   "$name moved out of Not-For-Us state",
		   "The package '$name' has been moved out of the Not-For-Us ".
		   "state by " . $conf->get('DB_USER') . ".\n".
		   "It should probably also be removed from ".
		   "Packages-arch-specific or\n".
		   "the action was wrong.\n" )
	    if $conf->get('DB_NOTFORUS_MAINTAINER_EMAIL');
    }
    else {
	change_state( \$pkg, 'Not-For-Us' );
	$pkg->{'Package'} = $name;
	delete $pkg->{'Builder'};
	delete $pkg->{'Depends'};
	delete $pkg->{'BuildPri'};
	delete $pkg->{'Binary-NMU-Version'};
	delete $pkg->{'Binary-NMU-Changelog'};
	log_ta( $pkg, "--no-build" );
	print "$name: registered as unsuitable\n" if $conf->get('VERBOSE');

	send_mail( $conf->get('DB_NOTFORUS_MAINTAINER_EMAIL'),
		   "$name set to Not-For-Us",
		   "The package '$name' has been set to state Not-For-Us ".
		   "by " . $conf->get('DB_USER') . ".\n".
		   "It should probably also be added to ".
		   "Packages-arch-specific or\n".
		   "the Not-For-Us state is wrong.\n" )
	    if $conf->get('DB_NOTFORUS_MAINTAINER_EMAIL');
    }
    $db{$name} = $pkg;
}

sub add_one_needsbuild ($$) {
    my $name = shift;
    my $version = shift;
    my $state;
    my $pkg = $db{$name};

    if (!defined($pkg)) {
	print "$name: not registered; can't give back.\n";
	return;
    }
    $state = $pkg->{'State'};

    if ($state eq "Dep-Wait") {
	if ($conf->get('DB_OVERRIDE')) {
	    print "$name: Forcing source dependency list to be cleared\n";
	}
	else {
	    print "$name: waiting for source dependencies. Skipping\n",
	    "  (use --override to clear dependency list and ",
	    "give back anyway)\n";
	    return;
	}
    }
    elsif (!isin( $state, qw(Building Built Build-Attempted))) {
	print "$name: not taken for building (state is $state).";
	if ($conf->get('DB_OVERRIDE')) {
	    print "\n$name: Forcing give-back\n";
	}
	else {
	    print " Skipping.\n";
	    return;
	}
    }
    if (defined ($pkg->{'Builder'}) && $conf->get('DB_USER') ne $pkg->{'Builder'} &&
	!($pkg->{'Builder'} =~ /^(\w+)-\w+/ && $1 eq $conf->get('DB_USER'))) {
	print "$name: not taken by you, but by ".
	    "$pkg->{'Builder'}. Skipping.\n";
	return;
    }
    if (!pkg_version_eq($pkg, $version)) {
	print "$name: version mismatch ($pkg->{'Version'} registered). ",
	"Skipping.\n";
	return;
    }
    change_state( \$pkg, 'Needs-Build' );
    delete $pkg->{'Builder'};
    delete $pkg->{'Depends'};
    log_ta( $pkg, "--give-back" );
    $db{$name} = $pkg;
    print "$name: given back\n" if $conf->get('VERBOSE');
}

sub set_one_binnmu ($$) {
    my $name = shift;
    my $version = shift;
    my $pkg = $db{$name};
    my $state;

    if (!defined($pkg)) {
	print "$name: not registered; can't register for binNMU.\n";
	return;
    }
    my $db_ver = $pkg->{'Version'};

    if (!version_eq($db_ver, $version)) {
	print "$name: version mismatch ($db_ver registered). ",
	"Skipping.\n";
	return;
    }
    $state = $pkg->{'State'};

    if (defined $pkg->{'Binary-NMU-Version'}) {
	if ($conf->get('DB_BIN_NMU_VERSION') == 0) {
	    change_state( \$pkg, 'Installed' );
	    delete $pkg->{'Builder'};
	    delete $pkg->{'Depends'};
	    delete $pkg->{'Binary-NMU-Version'};
	    delete $pkg->{'Binary-NMU-Changelog'};
	} elsif ($conf->get('DB_BIN_NMU_VERSION') <= $pkg->{'Binary-NMU-Version'}) {
	    print "$name: already building binNMU $pkg->{'Binary-NMU-Version'}\n";
	    return;
	} else {
	    $pkg->{'Binary-NMU-Version'} = $conf->get('DB_BIN_NMU_VERSION');
	    $pkg->{'Binary-NMU-Changelog'} = $conf->get('DB_FAIL_REASON');
	    $pkg->{'Notes'} = 'out-of-date';
	    $pkg->{'BuildPri'} = $pkg->{'PermBuildPri'}
	    if (defined $pkg->{'PermBuildPri'});
	}
	log_ta( $pkg, "--binNMU" );
	$db{$name} = $pkg;
	return;
    } elsif ($conf->get('DB_BIN_NMU_VERSION')) {
	print "${name}_$version: no scheduled binNMU to cancel.\n";
	return;
    }

    if ($state ne 'Installed') {
	print "${name}_$version: not installed; can't register for binNMU.\n";
	return;
    }

    my $fullver = binNMU_version($version,$conf->get('DB_BIN_NMU_VERSION'));
    if (version_lesseq($fullver, $pkg->{'Installed-Version'})) {
	print "$name: binNMU $fullver is not newer than current version $pkg->{'Installed-Version'}\n";
	return;
    }

    change_state( \$pkg, 'Needs-Build' );
    delete $pkg->{'Builder'};
    delete $pkg->{'Depends'};
    $pkg->{'Binary-NMU-Version'} = $conf->get('DB_BIN_NMU_VERSION');
    $pkg->{'Binary-NMU-Changelog'} = $conf->get('DB_FAIL_REASON');
    $pkg->{'Notes'} = 'out-of-date';
    log_ta( $pkg, "--binNMU" );
    $db{$name} = $pkg;
    print "${name}: registered for binNMU $fullver\n" if $conf->get('VERBOSE');
}

sub set_one_buildpri ($$$) {
    my $name = shift;
    my $version = shift;
    my $key = shift;
    my $pkg = $db{$name};
    my $state;

    if (!defined($pkg)) {
	print "$name: not registered; can't set priority.\n";
	return;
    }
    $state = $pkg->{'State'};

    if ($state eq "Not-For-Us") {
	print "$name: not suitable for this architecture. Skipping.\n";
	return;
    } elsif ($state eq "Failed-Removed") {
	print "$name: failed previously and doesn't need building. Skipping.\n";
	return;
    }
    if (!pkg_version_eq($pkg, $version)) {
	print "$name: version mismatch ($pkg->{'Version'} registered). ",
	"Skipping.\n";
	return;
    }
    if ( $conf->get('DB_BUILD_PRIORITY') == 0 ) {
	delete $pkg->{'BuildPri'}
	if $key eq 'PermBuildPri' and defined $pkg->{'BuildPri'}
	and $pkg->{'BuildPri'} == $pkg->{$key};
	delete $pkg->{$key};
    } else {
	$pkg->{'BuildPri'} = $conf->get('DB_BUILD_PRIORITY')
	    if $key eq 'PermBuildPri';
	$pkg->{$key} = $conf->get('DB_BUILD_PRIORITY');
    }
    $db{$name} = $pkg;
    print "$name: set to build priority " .
	$conf->get('DB_BUILD_PRIORITY') . "\n" if $conf->get('VERBOSE');
}

sub add_one_depwait ($$) {
    my $name = shift;
    my $version = shift;
    my $state;
    my $pkg = $db{$name};

    if (!defined($pkg)) {
	print "$name: not registered yet.\n";
	return;
    }
    $state = $pkg->{'State'};

    if ($state eq "Dep-Wait") {
	print "$name: merging with previously registered dependencies\n";
    }

    if (isin( $state, qw(Needs-Build Failed))) {
	print "$name: Warning: not registered for building previously, ".
	    "but processing anyway.\n";
    }
    elsif ($state eq "Not-For-Us") {
	print "$name: not suitable for this architecture anyway. Skipping.\n";
	return;
    }
    elsif ($state eq "Failed-Removed") {
	print "$name: failed previously and doesn't need building. Skipping.\n";
	return;
    }
    elsif ($state eq "Installed") {
	print "$name: Is already installed in archive. Skipping.\n";
	return;
    }
    elsif ($state eq "Uploaded") {
	print "$name: Is already uploaded. Skipping.\n";
	return;
    }
    elsif ($pkg->{'Builder'} &&
	   $conf->get('DB_USER') ne $pkg->{'Builder'}) {
	print "$name: not taken by you, but by ".
	    "$pkg->{'Builder'}. Skipping.\n";
	return;
    }
    elsif ( !pkg_version_eq($pkg,$version)) {
	print "$name: version mismatch ".
	    "($pkg->{'Version'} ".
	    "by $pkg->{'Builder'})\n";
	return;
    }
    elsif ($conf->get('DB_FAIL_REASON') =~ /^\s*$/ ||
	   !parse_deplist( $conf->get('DB_FAIL_REASON'), 1 )) {
	print "$name: Bad dependency list\n";
	return;
    }
    change_state( \$pkg, 'Dep-Wait' );
    $pkg->{'Builder'} = $conf->get('DB_USER');
    if (defined $pkg->{'PermBuildPri'}) {
	$pkg->{'BuildPri'} = $pkg->{'PermBuildPri'};
    } else {
	delete $pkg->{'BuildPri'};
    }
    my $deplist = parse_deplist( $pkg->{'Depends'}, 0 );
    my $new_deplist = parse_deplist( $conf->get('DB_FAIL_REASON'), 0 );
    # add new dependencies, maybe overwriting old entries
    foreach (keys %$new_deplist) {
	$deplist->{$_} = $new_deplist->{$_};
    }
    $pkg->{'Depends'} = build_deplist($deplist);
    log_ta( $pkg, "--dep-wait" );
    $db{$name} = $pkg;
    print "$name: registered as waiting for dependencies\n" if $conf->get('VERBOSE');
}


sub parse_sources ($) {
    my %pkgs;
    my %srcver;
    my $name;
    my $full = shift;

    local($/) = ""; # read in paragraph mode
    while( <> ) {
	my( $version, $arch, $section, $priority, $builddep, $buildconf, $binaries );
	s/\s*$//m;
	/^Package:\s*(\S+)$/mi and $name = $1;
	/^Version:\s*(\S+)$/mi and $version = $1;
	/^Architecture:\s*(\S+)$/mi and $arch = $1;
	/^Section:\s*(\S+)$/mi and $section = $1;
	/^Priority:\s*(\S+)$/mi and $priority = $1;
	/^Build-Depends:\s*(.*)$/mi and $builddep = $1;
	/^Build-Conflicts:\s*(.*)$/mi and $buildconf = $1;
	/^Binary:\s*(.*)$/mi and $binaries = $1;

	next if (defined $srcver{$name} and version_less( $version, $srcver{$name} ));
	$srcver{$name} = $version;
	if ($buildconf) {
	    $buildconf = join( ", ", map { "!$_" } split( /\s*,\s*/, $buildconf ));
	    if ($builddep) {
		$builddep .= "," . $buildconf;
	    } else {
		$builddep = $buildconf;
	    }
	}

	$pkgs{$name}{'dep'} = defined $builddep ? $builddep : "";
	$pkgs{$name}{'ver'} = $version;
	$pkgs{$name}{'bin'} = $binaries;
	my $pkg = $db{$name};

	if (defined $pkg) {
	    my $change = 0;

	    if ($arch eq "all" && !version_less( $version, $pkg->{'Version'} )) {
		# package is now Arch: all, delete it from db
		change_state( \$pkg, 'deleted' );
		log_ta( $pkg, "--merge-sources" );
		print "$name ($pkg->{'Version'}): deleted ".
		    "from database, because now Arch: all\n"
		    if $conf->get('VERBOSE');
		delete $db{$name};
		next;
	    }

	    # The "Version" should always be the source version --
	    # not a possible binNMU version number.
	    $pkg->{'Version'} = $version, $change++
		if ($pkg->{'State'} eq 'Installed' and
		    !version_eq( $pkg->{'Version'}, $version));
	    # Always update priority and section, if available
	    $pkg->{'Priority'} = $priority, $change++
		if defined $priority && (!defined($pkg->{'Priority'}) ||
					 $pkg->{'Priority'} ne $priority);
	    $pkg->{'Section'} = $section, $change++
		if defined $section && (!defined($pkg->{'Section'}) ||
					$pkg->{'Section'} ne $section);
	    $db{$name} = $pkg if $change;
	}
    }
    # Now that we only have the latest source version, build the list
    # of binary packages from the Sources point of view
    foreach $name (keys %pkgs) {
	foreach my $bin (split( /\s*,\s*/, $pkgs{$name}{'bin'} ) ) {
	    $merge_binsrc{$bin} = $name;
	}
    }
    # remove installed packages that no longer have source available
    # or binaries installed
    foreach $name (keys %db) {
	next if $name =~ /^_/;
	my $pkg = $db{$name};
	if (not defined($pkgs{$name})) {
	    change_state( \$pkg, 'deleted' );
	    log_ta( $pkg, "--merge-sources" );
	    print "$name ($pkg->{'Version'}): ".
		"deleted from database, because ".
		"not in Sources anymore\n"
		if $conf->get('VERBOSE');
	    delete $db{$name};
	} else {
	    next if !isin( $pkg->{'State'}, qw(Installed) );
	    if ($full && not defined $merge_srcvers{$name}) {
		change_state( \$pkg, 'deleted' );
		log_ta( $pkg, "--merge-sources" );
		print "$name ($pkg->{'Version'}): ".
		    "deleted from database, because ".
		    "binaries don't exist anymore\n"
		    if $conf->get('VERBOSE');
		delete $db{$name};
	    } elsif ($full && version_less( $merge_srcvers{$name}, $pkg->{'Version'})) {
		print "$name ($pkg->{'Version'}): ".
		    "package is Installed but binaries are from ".
		    $merge_srcvers{$name}. "\n"
		    if $conf->get('VERBOSE');
	    }
	}
    }
    return \%pkgs;
}

# This function looks through a Packages file and sets the state of
# packages to 'Installed'
sub parse_packages () {
    my $installed;

    local($/) = ""; # read in paragraph mode
    while( <> ) {
	my( $name, $version, $depends, $source, $sourcev, $architecture, $provides, $binaryv, $binnmu );
	s/\s*$//m;
	/^Package:\s*(\S+)$/mi and $name = $1;
	/^Version:\s*(\S+)$/mi and $version = $1;
	/^Depends:\s*(.*)$/mi and $depends = $1;
	/^Source:\s*(\S+)(\s*\((\S+)\))?$/mi and ($source,$sourcev) = ($1, $3);
	/^Architecture:\s*(\S+)$/mi and $architecture = $1;
	/^Provides:\s*(.*)$/mi and $provides = $1;

	next if !$name || !$version;
	next if ($conf->get('ARCH') ne $architecture and $architecture ne "all");
	next if (defined ($installed->{$name}) and $installed->{$name}{'Version'} ne "" and
		 version_lesseq( $version, $installed->{$name}{'Version'} ));
	$installed->{$name}{'Version'} = $version;
	$installed->{$name}{'Depends'} = $depends;
	$installed->{$name}{'all'} = 1 if $architecture eq "all";
	undef $installed->{$name}{'Provider'};
	$installed->{$name}{'Source'} = $source ? $source : $name;

	if ($provides) {
	    foreach (split( /\s*,\s*/, $provides )) {
		if (not defined ($installed->{$_})) {
		    $installed->{$_}{'Version'} = "";
		    $installed->{$_}{'Provider'} = $name;
		}
	    }
	}
	if ( $version =~ /\+b(\d+)$/ ) {
	    $binnmu = $1;
	}
	$version = $sourcev if $sourcev;
	$binaryv = $version;
	$binaryv =~ s/\+b\d+$//;
	$installed->{$name}{'Sourcev'} = $sourcev ? $sourcev : $binaryv;
	$binaryv .= "+b$binnmu" if defined($binnmu);

	next if $architecture ne $conf->get('ARCH');
	$name = $source if $source;
	next if defined($merge_srcvers{$name}) and $merge_srcvers{$name} eq $version;

	$merge_srcvers{$name} = $version;

	my $pkg = $db{$name};

	if (defined $pkg) {
	    if (isin( $pkg->{'State'}, qw(Not-For-Us)) ||
		(isin($pkg->{'State'}, qw(Installed)) &&
		 version_lesseq($binaryv, $pkg->{'Installed-Version'}))) {
		print "Skipping $name because State == $pkg->{'State'}\n"
		    if $conf->get('VERBOSE') >= 2;
		next;
	    }
	    if ($pkg->{'Binary-NMU-Version'} ) {
		my $nmuver = binNMU_version($pkg->{'Version'}, $pkg->{'Binary-NMU-Version'});
		if (version_less( $binaryv, $nmuver )) {
		    print "Skipping $name ($version) because have newer ".
			"version ($nmuver) in db.\n"
			if $conf->get('VERBOSE') >= 2;
		    next;
		}
	    } elsif (version_less($version, $pkg->{'Version'})) {
		print "Skipping $name ($version) because have newer ".
		    "version ($pkg->{'Version'}) in db.\n"
		    if $conf->get('VERBOSE') >= 2;
		next;
	    }

	    if (!pkg_version_eq($pkg, $version) &&
		$pkg->{'State'} ne "Installed") {
		warn "Warning: $name: newer version than expected appeared ".
		    "in archive ($version vs. $pkg->{'Version'})\n";
		delete $pkg->{'Builder'};
	    }

	    if (!isin( $pkg->{'State'}, qw(Uploaded) )) {
		warn "Warning: Package $name was not in uploaded state ".
		    "before (but in '$pkg->{'State'}').\n";
		delete $pkg->{'Builder'};
		delete $pkg->{'Depends'};
	    }
	} else {
	    $pkg = {};
	    $pkg->{'Version'} = $version;
	}

	change_state( \$pkg, 'Installed' );
	$pkg->{'Package'} = $name;
	$pkg->{'Installed-Version'} = $binaryv;
	if (defined $pkg->{'PermBuildPri'}) {
	    $pkg->{'BuildPri'} = $pkg->{'PermBuildPri'};
	} else {
	    delete $pkg->{'BuildPri'};
	}
	$pkg->{'Version'} = $version
	    if version_less( $pkg->{'Version'}, $version);
	delete $pkg->{'Binary-NMU-Version'};
	delete $pkg->{'Binary-NMU-Changelog'};
	log_ta( $pkg, "--merge-packages" );
	$db{$name} = $pkg;
	print "$name ($version) is up-to-date now.\n" if $conf->get('VERBOSE');
    }

    check_dep_wait( "--merge-packages", $installed );
    return $installed;
}

sub pretend_avail (@) {
    my ($package, $name, $version, $installed);

    foreach $package (@_) {
	$package =~ s,^.*/,,; # strip path
	$package =~ s/\.(dsc|diff\.gz|tar\.gz|deb)$//; # strip extension
	$package =~ s/_[\w\d]+\.changes$//; # strip extension
	if ($package =~ /^([\w\d.+-]+)_([\w\d:.+~-]+)/) {
	    ($name,$version) = ($1,$2);
	}
	else {
	    warn "$package: can't extract package name and version ".
		"(bad format)\n";
	    next;
	}
	$installed->{$name}{'Version'} = $version;
    }

    check_dep_wait( "--pretend-avail", $installed );
}

sub check_dep_wait ($$) {
    my $action = shift;
    my $installed = shift;

    # check all packages in state Dep-Wait if dependencies are all
    # available now
    my $name;
    foreach $name (keys %db) {
	next if $name =~ /^_/;
	my $pkg = $db{$name};
	next if $pkg->{'State'} ne "Dep-Wait";
	my $deps = $pkg->{'Depends'};
	if (!$deps) {
	    print "$name: was in state Dep-Wait, but with empty ",
	    "dependencies!\n";
	    goto make_needs_build;
	}
	my $deplist = parse_deplist($deps, 0);
	my $new_deplist;
	my $allok = 1;
	my @removed_deps;
	foreach (keys %$deplist) {
	    if (!exists $installed->{$_} ||
		($deplist->{$_}->{'Rel'} && $deplist->{$_}->{'Version'} &&
		 !version_compare( $installed->{$_}{'Version'},
				   $deplist->{$_}->{'Rel'},
				   $deplist->{$_}->{'Version'}))) {
		$allok = 0;
		$new_deplist->{$_} = $deplist->{$_};
	    }
	    else {
		push( @removed_deps, $_ );
	    }
	}
	if ($allok) {
	  make_needs_build:
	    change_state( \$pkg, 'Needs-Build' );
	    log_ta( $pkg, $action );
	    delete $pkg->{'Builder'};
	    delete $pkg->{'Depends'};
	    print "$name ($pkg->{'Version'}) has all ",
	    "dependencies available now\n" if $conf->get('VERBOSE');
	    $new_vers{$name}++;
	    $db{$name} = $pkg;
	}
	elsif (@removed_deps) {
	    $pkg->{'Depends'} = build_deplist( $new_deplist );
	    print "$name ($pkg->{'Version'}): some dependencies ",
	    "(@removed_deps) available now, but not all yet\n"
		if $conf->get('VERBOSE');
	    $db{$name} = $pkg;
	}
    }
}

# This function accepts quinn-diff output (either from a file named on
# the command line, or on stdin) and sets the packages named there to
# state 'Needs-Build'.
sub parse_quinn_diff ($) {
    my $partial = shift;
    my %quinn_pkgs;
    my $dubious = "";

    while( <> ) {
	my $change = 0;
	next if !m,^([-\w\d/]*)/                        # section
		   ([-\w\d.+]+)_                        # package name
		   ([\w\d:.~+-]+)\.dsc\s*		# version
		   \[([^:]*):				# priority
		   ([^]]+)\]\s*$,x;			# rest of notes
	my($section,$name,$version,$priority,$notes) = ($1, $2, $3, $4, $5);
	$quinn_pkgs{$name}++;
	$section ||= "unknown";
	$priority ||= "unknown";
	$priority = "unknown" if $priority eq "-";
	$priority = "standard" if ($name eq "debian-installer");

	my $pkg = $db{$name};

	# Always update section and priority.
	if (defined($pkg)) {

	    $pkg->{'Section'}  = $section, $change++ if not defined
		$pkg->{'Section'} or $section ne "unknown";
	    $pkg->{'Priority'} = $priority, $change++ if not defined
		$pkg->{'Priority'} or $priority ne "unknown";
	}

	if (defined($pkg) &&
	    $pkg->{'State'} =~ /^Dep-Wait/ &&
	    version_less( $pkg->{'Version'}, $version )) {
	    change_state( \$pkg, 'Dep-Wait' );
	    $pkg->{'Version'}  = $version;
	    delete $pkg->{'Binary-NMU-Version'};
	    delete $pkg->{'Binary-NMU-Changelog'};
	    log_ta( $pkg, "--merge-quinn" );
	    $change++;
	    print "$name ($version) still waiting for dependencies.\n"
		if $conf->get('VERBOSE');
	}
	elsif (defined($pkg) &&
	       $pkg->{'State'} =~ /-Removed$/ &&
	       version_eq($pkg->{'Version'}, $version)) {
	    # reinstantiate a package that has been removed earlier
	    # (probably due to a quinn-diff malfunction...)
	    my $newstate = $pkg->{'State'};
	    $newstate =~ s/-Removed$//;
	    change_state( \$pkg, $newstate );
	    $pkg->{'Version'}  = $version;
	    $pkg->{'Notes'}    = $notes;
	    log_ta( $pkg, "--merge-quinn" );
	    $change++;
	    print "$name ($version) reinstantiated to $newstate.\n"
		if $conf->get('VERBOSE');
	}
	elsif (defined($pkg) &&
	       $pkg->{'State'} eq "Not-For-Us" &&
	       version_less( $pkg->{'Version'}, $version )) {
	    # for Not-For-Us packages just update the version etc., but
	    # keep the state
	    change_state( \$pkg, "Not-For-Us" );
	    $pkg->{'Package'}  = $name;
	    $pkg->{'Version'}  = $version;
	    $pkg->{'Notes'}    = $notes;
	    delete $pkg->{'Builder'};
	    log_ta( $pkg, "--merge-quinn" );
	    $change++;
	    print "$name ($version) still Not-For-Us.\n" if $conf->get('VERBOSE');
	}
	elsif (!defined($pkg) ||
	       $pkg->{'State'} ne "Not-For-Us" &&
	       (version_less( $pkg->{'Version'}, $version ) ||
		($pkg->{'State'} eq "Installed" && version_less($pkg->{'Installed-Version'}, $version)))) {
	    if (defined( $pkg->{'State'} ) &&
		isin($pkg->{'State'}, qw(Building Built Build-Attempted))) {
		send_mail( $pkg->{'Builder'},
			   "new version of $name (dist=" . $conf->get('DISTRIBUTION') . ")",
			   "As far as I'm informed, you're currently ".
			   "building the package $name\n".
			   "in version $pkg->{'Version'}.\n\n".
			   "Now there's a new source version $version. ".
			   "If you haven't finished\n".
			   "compiling $name yet, you can stop it to ".
			   "save some work.\n".
			   "Just to inform you...\n".
			   "(This is an automated message)\n" );
		print "$name: new version ($version) while building ".
		    "$pkg->{'Version'} -- sending mail ".
		    "to builder ($pkg->{'Builder'})\n"
		    if $conf->get('VERBOSE');
	    }
	    change_state( \$pkg, 'Needs-Build' );
	    $pkg->{'Package'}  = $name;
	    $pkg->{'Version'}  = $version;
	    $pkg->{'Section'}  = $section;
	    $pkg->{'Priority'} = $priority;
	    $pkg->{'Notes'}    = $notes;
	    delete $pkg->{'Builder'};
	    delete $pkg->{'Binary-NMU-Version'};
	    delete $pkg->{'Binary-NMU-Changelog'};
	    log_ta( $pkg, "--merge-quinn" );
	    $new_vers{$name}++;
	    $change++;
	    print "$name ($version) needs rebuilding now.\n" if $conf->get('VERBOSE');
	}
	elsif (defined($pkg) &&
	       !version_eq( $pkg->{'Version'}, $version ) &&
	       isin( $pkg->{'State'}, qw(Installed Not-For-Us) )) {
	    print "$name: skipping because version in db ".
		"($pkg->{'Version'}) is >> than ".
		"what quinn-diff says ($version) ".
		"(state is $pkg->{'State'})\n"
		if $conf->get('VERBOSE');
	    $dubious .= "$pkg->{'State'}: ".
		"db ${name}_$pkg->{'Version'} >> ".
		"quinn $version\n" if !$partial;
	}
	elsif ($conf->get('VERBOSE') >= 2) {
	    if ($pkg->{'State'} eq "Not-For-Us") {
		print "Skipping $name because State == ".
		    "$pkg->{'State'}\n";
	    }
	    elsif (!version_less($pkg->{'Version'}, $version)) {
		print "Skipping $name because version in db ".
		    "($pkg->{'Version'}) is >= than ".
		    "what quinn-diff says ($version)\n";
	    }
	}
	$db{$name} = $pkg if $change;
    }

    if ($dubious) {
	send_mail( $conf->get('DB_MAINTAINER_EMAIL'),
		   "Dubious versions in " . $conf->get('DISTRIBUTION') . " " .
		   $conf->get('DB_BASE_NAME') . " database",
		   "The following packages have a newer version in the ".
		   "wanna-build database\n".
		   "than what quinn-diff says, and this is strange for ".
		   "their state\n".
		   "It could be caused by a lame mirror, or the version ".
		   "in the database\n".
		   "is wrong.\n\n".
		   $dubious );
    }

    # Now re-check the DB for packages in states Needs-Build, Failed,
    # or Dep-Wait and remove them if they're not listed anymore by quinn-diff.
    if ( !$partial ) {
	my $name;
	foreach $name (keys %db) {
	    next if $name =~ /^_/;
	    my $pkg = $db{$name};
	    next if defined $pkg->{'Binary-NMU-Version'};
	    next if !isin($pkg->{'State'},
			  qw(Needs-Build Building Built
			     Build-Attempted Uploaded Failed
			     Dep-Wait));
	    my $virtual_delete = $pkg->{'State'} eq 'Failed';

	    if (!$quinn_pkgs{$name}) {
		change_state( \$pkg, $virtual_delete ?
			      $pkg->{'State'}."-Removed" :
			      'deleted' );
		log_ta( $pkg, "--merge-quinn" );
		print "$name ($pkg->{'Version'}): ".
		    ($virtual_delete ? "(virtually) " : "") . "deleted ".
		    "from database, because not in quinn-diff anymore\n"
		    if $conf->get('VERBOSE');
		if ($virtual_delete) {
		    $db{$name} = $pkg;
		} else {
		    delete $db{$name};
		}
	    }
	}
    }
}

sub send_reupload_mail ($$$$$) {
    my $to = shift;
    my $pkg = shift;
    my $version = shift;
    my $dist = shift;
    my $other_dist = shift;

    send_mail( $to,
	       "Please reupload ${pkg}_${'Version'} for $dist",
	       "You have recently built (or are currently building)\n".
	       "${pkg}_${'Version'} for $other_dist.\n".
	       "This version is now also needed in the $dist distribution.\n".
	       "Please reupload the files now present in the Debian archive\n".
	       "(best with buildd-reupload).\n" );
}


# for sorting priorities and sections
BEGIN {
    %prioval = ( required             => -5,
		 important            => -4,
		 standard             => -3,
		 optional             => -2,
		 extra                => -1,
		 unknown              => -1 );
    %sectval = (
	libs			=> -200,
	'debian-installer'	=> -199,
	base			=> -198,
	devel			=> -197,
	shells			=> -196,
	perl			=> -195,
	python			=> -194,
	graphics		=> -193,
	admin			=> -192,
	utils			=> -191,
	x11			=> -190,
	editors		=> -189,
	net			=> -188,
	mail			=> -187,
	news			=> -186,
	tex			=> -185,
	text			=> -184,
	web			=> -183,
	doc			=> -182,
	interpreters		=> -181,
	gnome			=> -180,
	kde			=> -179,
	games			=> -178,
	misc			=> -177,
	otherosfs		=> -176,
	oldlibs		=> -175,
	libdevel		=> -174,
	sound			=> -173,
	math			=> -172,
	science		=> -171,
	comm			=> -170,
	electronics		=> -169,
	hamradio		=> -168,
	embedded		=> -166,
	);
    foreach my $i (keys %sectval) {
	$sectval{"contrib/$i"} = $sectval{$i}+40;
	$sectval{"non-free/$i"} = $sectval{$i}+80;
    }
    $sectval{'unknown'}	= -165;

    %catval =  ( "none"			      => -20,
		 "uploaded-fixed-pkg" => -19,
		 "fix-expected"       => -18,
		 "reminder-sent"      => -17,
		 "nmu-offered"        => -16,
		 "easy"               => -15,
		 "medium"		      => -14,
		 "hard"		          => -13,
		 "compiler-error"     => -12 );
}

sub sort_list_func () {
    my( $letter, $x, $ax, $bx );

    foreach $letter (split( "", $conf->get('DB_LIST_ORDER') )) {
      SWITCH: foreach ($letter) {
	  /P/ && do {
	      $x = $b->{'BuildPri'} <=> $a->{'BuildPri'};
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /p/ && do {
	      $x = $prioval{$a->{'Priority'}} <=> $prioval{$b->{'Priority'}};
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /s/ && do {
	      $x = $sectval{$a->{'Section'}} <=> $sectval{$b->{'Section'}};
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /n/ && do {
	      $x = $a->{'Package'} cmp $b->{'Package'};
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /b/ && do {
	      $x = $a->{'Builder'} cmp $b->{'Builder'};
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /c/ && do {
	      $ax = ($a->{'Notes'} =~ /^(out-of-date|partial)/) ? 0 :
		  ($a->{'Notes'} =~ /^uncompiled/) ? 2 : 1;
	      $bx = ($b->{'Notes'} =~ /^(out-of-date|partial)/) ? 0 :
		  ($b->{'Notes'} =~ /^uncompiled/) ? 2 : 1;
	      $x = $ax <=> $bx;
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /f/ && do {
	      my $ca = exists $a->{'Failed-Category'} ?
		  $a->{'Failed-Category'} : "none";
	      my $cb = exists $b->{'Failed-Category'} ?
		  $b->{'Failed-Category'} : "none";
	      $x = $catval{$ca} <=> $catval{$cb};
	      return $x if $x != 0;
	      last SWITCH;
	  };
	  /S/ && do {
	      my $pa = $prioval{$a->{'Priority'}} >
		  $prioval{'standard'};
	      my $pb = $prioval{$b->{'Priority'}} >
		  $prioval{'standard'};
	      $x = $pa <=> $pb;
	      return $x if $x != 0;
	      last SWITCH;
	  };
      }
    }
    return 0;
}

sub list_packages ($) {
    my $state = shift;
    my( $name, $pkg, @list );
    my $cnt = 0;
    my %scnt;
    my $ctime = time;

    foreach $name (keys %db) {
	next if $name =~ /^_/;
	$pkg = $db{$name};
	next if $state ne "all" && $pkg->{'State'} !~ /^\Q$state\E$/i;
	next if $conf->get('DB_USER') && (lc($state) ne 'needs-build' &&
					  $pkg->{'Builder'} ne $conf->get('DB_USER'));
	next if $conf->get('DB_CATEGORY') && $pkg->{'State'} eq "Failed" &&
	    $pkg->{'Failed-Category'} ne $conf->get('DB_CATEGORY');
	next if ($conf->get('DB_LIST_MIN_AGE') > 0 &&
		 ($ctime-parse_date($pkg->{'State-Change'})) < $conf->get('DB_LIST_MIN_AGE'))||
		 ($conf->get('DB_LIST_MIN_AGE') < 0 &&
		  ($ctime-parse_date($pkg->{'State-Change'})) > -$conf->get('DB_LIST_MIN_AGE'));
	push( @list, $pkg );
    }

    foreach $pkg (sort sort_list_func @list) {
	print "$pkg->{'Section'}/$pkg->{'Package'}_$pkg->{'Version'}";
	print ": $pkg->{'State'}"
	    if $state eq "all";
	print " by $pkg->{'Builder'}"
	    if $pkg->{'State'} ne "Needs-Build" && $pkg->{'Builder'};
	print " [$pkg->{'Priority'}:$pkg->{'Notes'}";
	print ":PREV-FAILED"
	    if $pkg->{'Previous-State'} =~ /^Failed/;
	print ":bp{" . $pkg->{'BuildPri'} . "}"
	    if exists $pkg->{'BuildPri'};
	print ":binNMU{" . $pkg->{'Binary-NMU-Version'} . "}"
	    if exists $pkg->{'Binary-NMU-Version'};
	print "]\n";
	print "  Reasons for failing:\n",
	"    [Category: ",
	exists $pkg->{'Failed-Category'} ? $pkg->{'Failed-Category'} : "none",
	"]\n    ",
	join("\n    ",split("\n",$pkg->{'Failed'})), "\n"
	    if $pkg->{'State'} =~ /^Failed/;
	print "  Dependencies: $pkg->{'Depends'}\n"
	    if $pkg->{'State'} eq "Dep-Wait";
	print "  Previous state was $pkg->{'Previous-State'} until ",
	"$pkg->{'State-Change'}\n"
	    if $conf->get('VERBOSE') && $pkg->{'Previous-State'};
	print "  Previous failing reasons:\n    ",
	join("\n    ",split("\n",$pkg->{'Old-Failed'})), "\n"
	    if $conf->get('VERBOSE') && $pkg->{'Old-Failed'};
	++$cnt;
	$scnt{$pkg->{'State'}}++ if $state eq "all";
    }
    if ($state eq "all") {
	foreach (sort keys %scnt) {
	    print "Total $scnt{$_} package(s) in state $_.\n";
	}
    }
    print "Total $cnt package(s)\n";

}

sub info_packages (@) {
    my( $name, $pkg, $key, $dist );
    my @firstkeys = qw(Package Version Builder State Section Priority
		       Installed-Version Previous-State State-Change);
    my @dists = $conf->get('DB_INFO_ALL_DISTS') ? keys %{$conf->get('DB_DISTRIBUTIONS')} : ($conf->get('DISTRIBUTION'));

    foreach $dist (@dists) {
	if ($dist ne $conf->get('DISTRIBUTION')) {
	    if (!-f db_filename( $dist ) || !open_other_db( $dist )) {
		warn "Cannot open database for $dist!\n";
		@dists = grep { $_ ne $dist } @dists;
	    }
	}
    }

    foreach $name (@_) {
	$name =~ s/_.*$//; # strip version
	foreach $dist (@dists) {
	    my $db = $dist ne $conf->get('DISTRIBUTION') ? $otherdb{$dist} : \%db;
	    my $pname = "$name" . ($conf->get('DB_INFO_ALL_DISTS') ? "($dist)" : "");

	    $pkg = $db->{$name};
	    if (!defined( $pkg )) {
		print "$pname: not registered\n";
		next;
	    }

	    print "$pname:\n";
	    foreach $key (@firstkeys) {
		next if !exists $pkg->{$key};
		my $val = $pkg->{$key};
		chomp( $val );
		$val = "\n$val" if isin( $key, qw(Failed Old-Failed));
		$val =~ s/\n/\n /g;
		printf "  %-20s: %s\n", $key, $val;
	    }
	    foreach $key (sort keys %$pkg) {
		next if isin( $key, @firstkeys );
		my $val = $pkg->{$key};
		chomp( $val );
		$val = "\n$val" if isin( $key, qw(Failed Old-Failed));
		$val =~ s/\n/\n /g;
		printf "  %-20s: %s\n", $key, $val;
	    }
	}
    }
}

sub forget_packages (@) {
    my( $name, $pkg, $key, $data );

    foreach $name (@_) {
	$name =~ s/_.*$//; # strip version
	$pkg = $db{$name};
	if (!defined( $pkg )) {
	    print "$name: not registered\n";
	    next;
	}

	$data = "";
	foreach $key (sort keys %$pkg) {
	    my $val = $pkg->{$key};
	    chomp( $val );
	    $val =~ s/\n/\n /g;
	    $data .= sprintf "  %-20s: %s\n", $key, $val;
	}
	send_mail( $conf->get('DB_MAINTAINER_EMAIL'),
		   "$name deleted from DB " . $conf->get('DB_BASE_NAME'),
		   "The package '$name' has been deleted from the database ".
		   "by " . $conf->get('DB_USER') . ".\n\n".
		   "Data registered about the deleted package:\n".
		   "$data\n" ) if $conf->get('DB_MAINTAINER_EMAIL');
	change_state( \$pkg, 'deleted' );
	log_ta( $pkg, "--forget" );
	delete $db{$name};
	print "$name: deleted from database\n" if $conf->get('VERBOSE');
    }
}

sub forget_users (@) {
    my( $name, $ui );
    my $change = 0;

    $ui = $db{'_userinfo'};
    foreach $name (@_) {
	if (!defined( $ui->{$name} )) {
	    print "$name: not registered\n";
	    next;
	}

	delete $ui->{$name};
	$change++;
	print "$name: deleted from database\n" if $conf->get('VERBOSE');
    }
    $db{'_userinfo'} = $ui if $change;
}

sub lock_db ($) {
    my $dist = shift;
    my $try = 0;
    my $lockfile = db_filename($dist) . ".lock";
    local( *F );

    print "Locking $dist database\n" if $conf->get('VERBOSE') >= 2;
  repeat:
    if (!sysopen( F, $lockfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, 0644 )){
	if ($! == EEXIST) {
	    # lock file exists, wait
	    goto repeat if !open( F, "<$lockfile" );
	    my $line = <F>;
	    close( F );
	    if ($line !~ /^(\d+)\s+([\w\d.-]+)$/) {
		warn "Bad lock file contents -- still trying\n";
	    }
	    else {
		my($pid, $usr) = ($1, $2);
		if (kill( 0, $pid ) == 0 && $! == ESRCH) {
		    # process doesn't exist anymore, remove stale lock
		    print "Removing stale lock file (pid $pid, user $usr)\n";
		    unlink( $lockfile );
		    goto repeat;
		}
		warn "Database locked by $usr -- please wait\n" if $try == 0;
	    }
	    if (++$try > 200) {
		# avoid the END routine removes the lock
		$main::keep_lock{$dist} = 1;
		die "Lock still present after 200 * 5 seconds.\n";
	    }
	    sleep 5;
	    goto repeat;
	}
	die "Can't create lock file $lockfile: $!\n";
    }
    F->print("$$ " . $conf->get('USERNAME') . "\n");
    F->close();
}

sub unlock_db ($) {
    my $dist = shift;
    my $lockfile = db_filename($dist) . ".lock";

    if (!$main::keep_lock{$dist}) {
	print "Unlocking $dist database\n" if $conf->get('VERBOSE') >= 2;
	unlink $lockfile;
    }
}

sub create_maintlock () {
    my $lockfile = db_filename("maintenance") . ".lock";
    my $try = 0;
    local( *F );

    print "Creating maintenance lock\n" if $conf->get('VERBOSE') >= 2;
  repeat:
    if (!sysopen( F, $lockfile, O_WRONLY|O_CREAT|O_TRUNC|O_EXCL, 0644 )){
	if ($! == EEXIST) {
	    # lock file exists, wait
	    goto repeat if !open( F, "<$lockfile" );
	    my $line = <F>;
	    close( F );
	    if ($line !~ /^(\d+)\s+([\w\d.-]+)$/) {
		warn "Bad maintenance lock file contents -- still trying\n";
	    }
	    else {
		my($pid, $usr) = ($1, $2);
		if (kill( 0, $pid ) == 0 && $! == ESRCH) {
		    # process doesn't exist anymore, remove stale lock
		    print "Removing stale lock file (pid $pid, user $usr)\n";
		    unlink( $lockfile );
		    goto repeat;
		}
		warn "Maintenance lock already exists by $usr -- ".
		    "please wait\n" if $try == 0;
	    }
	    if (++$try > 120) {
		die "Lock still present after 120 * 60 seconds.\n";
	    }
	    sleep 60;
	    goto repeat;
	}
	die "Can't create maintenance lock $lockfile: $!\n";
    }
    F->print(getppid(), " " . $conf->get('USERNAME') . "\n");
    F->close();
}

sub remove_maintlock () {
    my $lockfile = db_filename("maintenance") . ".lock";

    print "Removing maintenance lock\n" if $conf->get('VERBOSE') >= 2;
    unlink $lockfile;
}

sub waitfor_maintlock () {
    my $lockfile = db_filename("maintenance") . ".lock";
    my $try = 0;
    local( *F );

    print "Checking for maintenance lock\n" if $conf->get('VERBOSE') >= 2;
  repeat:
    if (open( F, "<$lockfile" )) {
	my $line = <F>;
	close( F );
	if ($line !~ /^(\d+)\s+([\w\d.-]+)$/) {
	    warn "Bad maintenance lock file contents -- still trying\n";
	}
	else {
	    my($pid, $usr) = ($1, $2);
	    if (kill( 0, $pid ) == 0 && $! == ESRCH) {
		# process doesn't exist anymore, remove stale lock
		print "Removing stale maintenance lock (pid $pid, user $usr)\n";
		unlink( $lockfile );
		return;
	    }
	    warn "Databases locked for general maintenance by $usr -- ".
		"please wait\n" if $try == 0;
	}
	if (++$try > 120) {
	    die "Lock still present after 120 * 60 seconds.\n";
	}
	sleep 60;
	goto repeat;
    }
}


sub read_db ($) {
         my $file = shift;

         print "Reading ASCII database from $file..." if $conf->get('VERBOSE') >= 1;
         open( F, "<$file" ) or
                 die "Can't open database $file: $!\n";

         local($/) = ""; # read in paragraph mode
         while( <F> ) {
                 my( %thispkg, $name );
                 s/[\s\n]+$//;
                 s/\n[ \t]+/\376\377/g;  # fix continuation lines
                 s/\376\377\s*\376\377/\376\377/og;

                 while( /^(\S+):[ \t]*(.*)[ \t]*$/mg ) {
                         my ($key, $val) = ($1, $2);
                         $val =~ s/\376\377/\n/g;
                         $thispkg{$key} = $val;
                 }
                 check_entry( \%thispkg );
                 # add to db
		 if (exists($thispkg{'Package'})) {
		     $name = $thispkg{'Package'};
		     $db{$name} = \%thispkg;
		 } elsif(exists($thispkg{'User'})) {
		     	my $userinfo = $db{'_userinfo'};
			$userinfo = {} if (!defined($userinfo));

			$name = $thispkg{'User'};
			$userinfo->{$name} = \%thispkg;

			$db{'_userinfo'} = $userinfo;
		 }
         }
         close( F );
         print "done\n" if $conf->get('VERBOSE') >= 1;
}

sub check_entry ($) {
    my $pkg = shift;
    my $field;

    return if $conf->get('DB_OPERATION') eq "manual-edit"; # no checks then

    # check for required fields
    if (!exists $pkg->{'Package'} && !exists $pkg->{'User'}) {
	print STDERR "Bad entry: ",
	join( "\n", map { "$_: $pkg->{$_}" } keys %$pkg ), "\n";
	die "Database entry lacks Package or User: field\n";
    }

    if (exists $pkg->{'Package'}) {
	if (!exists $pkg->{'Version'}) {
	    die "Database entry for package $pkg->{'Package'} lacks Version: field\n";
	}
	# if no State: field, generate one (for old db compat)
	if (!exists($pkg->{'State'})) {
	    $pkg->{'State'} =
		exists $pkg->{'Failed'} ? 'Failed' : 'Building';
	}
	# check state field
	die "Bad state $pkg->{'State'} of package $pkg->{Package}\n"
	    if !isin($pkg->{'State'},
		     qw(Needs-Build Building Built Build-Attempted
			Uploaded Installed Dep-Wait Failed
			Failed-Removed Not-For-Us) );
    }
    if (exists $pkg->{'User'}) {
	if (!exists $pkg->{'Last-Seen'}) {
	    die "Database entry for user $pkg->{'User'} lacks Last-Seen: field\n";
	}
    }
}

sub write_db ($) {
    my $file = shift;
    my($name,$pkg,$key);

    print "Writing ASCII database to $file..." if $conf->get('VERBOSE') >= 1;
    open( F, ">$file" ) or
	die "Can't open database $file: $!\n";

    foreach $name (sort keys %db) {
	my $pkg = $db{$name};
	if ($name eq '_userinfo') {
		foreach my $user (sort keys %{$pkg}) {
		    my $ui = $pkg->{$user};
		    print F "User: $user\n"
			if (!defined($ui->{'User'}));
		    foreach $key (keys %{$ui}) {
			my $val = $ui->{$key};
			chomp($val);
			$val =~ s/\n/\n /g;
			print F "$key: $val\n";
		}
		    print F "\n";
	    }
	} else {
	    foreach $key (keys %{$pkg}) {
		my $val = $pkg->{$key};
		chomp( $val );
		$val =~ s/\n/\n /g;
		print F "$key: $val\n";
	    }
	    print F "\n";
	}
    }
    close( F );
    print "done\n" if $conf->get('VERBOSE') >= 1;
}

sub change_state ($$;$) {
    my $pkgr = shift;
    my $pkg = $$pkgr;
    my $newstate = shift;
    my $for_dist = shift;
    my $db;
    if ($for_dist) {
	return if !open_other_db( $for_dist );
	$db = $otherdb{$for_dist};
	$pkg = \$db{$pkg->{'Package'}};
    }
    else {
	$db = \%db;
    }
    my $state = \$pkg->{'State'};

    return if defined($$state) and $$state eq $newstate;
    $pkg->{'Previous-State'} = $$state if defined($$state);


    $pkg->{'State-Change'} = $curr_date;

    if (defined($$state) and $$state eq 'Failed') {
	$pkg->{'Old-Failed'} =
	    "-"x20 . " $pkg->{'Version'} " . "-"x20 . "\n" .
	    $pkg->{'Failed'} . "\n" .
	    $pkg->{'Old-Failed'};
	delete $pkg->{'Failed'};
	delete $pkg->{'Failed-Category'};
    }
    $$state = $newstate;
}

sub open_other_db ($) {
    my $dist = shift;

    if (!tied(%{$otherdb{$dist}})) {
	lock_db( $dist );
	$otherdb_lock{$dist} = 1;
	if (!(tie %{$otherdb{$dist}}, 'MLDBM', db_filename($dist), 0, 0664)){
	    warn "Serious warning: Cannot open database for $dist\n";
	    unlock_db( $dist );
	    $otherdb_lock{$dist} = 0;
	    return 0;
	}
    }
    return 1;
}

sub log_ta ($$;$) {
    my $pkg = shift;
    my $action = shift;

    my $dist = $conf->get('DISTRIBUTION');
    my $db = \%db;
    my $str;
    my $prevstate;

    $prevstate = $pkg->{'Previous-State'};
    $str = "$action($dist): $pkg->{'Package'}_$pkg->{'Version'} ".
	"changed from $prevstate to $pkg->{'State'} ".
	"by " . $conf->get('USERNAME'). " as " . $conf->get('DB_USER') . ".";

    my $dbbase = $conf->get('DB_BASE_NAME');
    $dbbase =~ m#^([^/]+/)#;

    my $transactlog = $conf->get('DB_BASE_DIR') . "/$1" .
	$conf->get('DB_TRANSACTION_LOG');
    if (!open( LOG, ">>$transactlog" )) {
	warn "Can't open log file $transactlog: $!\n";
	return;
    }
    print LOG "$curr_date: $str\n";
    close( LOG );

    if (!($prevstate eq 'Failed' && $pkg->{'State'} eq 'Failed')) {
	$str .= " (with --override)"
	    if $conf->get('DB_OVERRIDE');
	$mail_logs .= "$str\n";
    }
}


sub dist_cmp ($$) {
    my $d1 = shift;
    my $d2 = shift;

    my $dist_order = $conf->get('DB_DISTRIBUTIONS');

    return $dist_order->{$d1}->{'priority'} <=> $dist_order->{$d2}->{'priority'};
}



sub send_mail ($$$) {
    my $to = shift;
    my $subject = shift;
    my $text = shift;

    my $from = $conf->get('DB_MAINTAINER_EMAIL');

    $from .= "\@" . $conf->get('HOSTNAME') if $from !~ /\@/;

    $to .= '@' . $conf->get('HOSTNAME') if $to !~ /\@/;
    $text =~ s/^\.$/../mg;
    local $SIG{'PIPE'} = 'IGNORE';
    open( PIPE,  "| " . $conf->get('MAILPROG') . " -oem $to" )
	or die "Can't open pipe to " . $conf->get('MAILPROG') . ": $!\n";
    chomp $text;
    print PIPE "From: $from\n";
    print PIPE "Subject: $subject\n\n";
    print PIPE "$text\n";
    close( PIPE );
}

sub db_filename ($) {
    my $dist = shift;
    return $conf->get('DB_BASE_DIR') . '/' . $conf->get('DB_BASE_NAME') . "-$dist";
}

# for parsing input to dep-wait
sub parse_deplist ($;$) {
    my $deps = shift;
    my $verify = shift;
    my %result;

    foreach (split( /\s*,\s*/, $deps )) {
        if ($verify) {
            # verification requires > starting prompts, no | crap
            if (!/^(\S+)\s*(\(\s*(>(?:[>=])?)\s*(\S+)\s*\))?\s*$/) {
                return 0;
            }
            next;
        }
        my @alts = split( /\s*\|\s*/, $_ );
        # Anything with an | is ignored, as it can be configured on a
        # per-buildd basis what will be installed
        next if $#alts != 0;
        $_ = shift @alts;

        if (!/^(\S+)\s*(\(\s*(>=|=|==|>|>>|<<|<=)\s*(\S+)\s*\))?\s*$/) {
            warn( "parse_deplist: bad dependency $_\n" );
            next;
        }
        my($dep, $rel, $relv) = ($1, $3, $4);
        $rel = ">>" if defined($rel) and $rel eq ">";
        $result{$dep}->{'Package'} = $dep;
        if ($rel && $relv) {
            $result{$dep}->{'Rel'} = $rel;
            $result{$dep}->{'Version'} = $relv;
        }
    }
    return 1 if $verify;
    return \%result;
}

# for parsing Build-Depends from Sources
sub parse_srcdeplist ($$$) {
    my $pkg = shift;
    my $deps = shift;
    my $arch = shift;
    my $dep;
    my @results;

    foreach $dep (split( /\s*,\s*/, $deps )) {
	my @alts = split( /\s*\|\s*/, $dep );
        # Anything with an | is ignored, as it can be configured on a
        # per-buildd basis what will be installed
        next if $#alts != 0;
	$_ = shift @alts;
        if (!/^([^\s([]+)\s*(\(\s*([<=>]+)\s*(\S+)\s*\))?(\s*\[([^]]+)\])?/) {
            warn( "parse_srcdeplist: bad dependency $_\n" );
            next;
        }
        my($dep, $rel, $relv, $archlist) = ($1, $3, $4, $6);
        if ($archlist) {
            $archlist =~ s/^\s*(.*)\s*$/$1/;
            my @archs = split( /\s+/, $archlist );
            my ($use_it, $ignore_it, $include) = (0, 0, 0);
            foreach (@archs) {
                if (/^!/) {
                    $ignore_it = 1 if substr($_, 1) eq $arch;
                } else {
                    $use_it = 1 if $_ eq $arch;
                    $include = 1;
                }
            }
            warn "Warning: inconsistent arch restriction on ",
	    "$pkg: $dep depedency\n"
		if $ignore_it && $use_it;
            next if $ignore_it || ($include && !$use_it);
        }
        my $neg = 0;
        if ($dep =~ /^!/) {
            $dep =~ s/^!\s*//;
            $neg = 1;
        }
        my $result;
        $result->{'Package'} = $dep;
        $result->{'Neg'} = $neg;
        if ($rel && $relv) {
            $result->{'Rel'} = $rel;
            $result->{'Version'} = $relv;
        }
        push @results, $result;

    }
    return \@results;
}

sub build_deplist ($) {
    my $list = shift;
    my($key, $result);

    foreach $key (keys %$list) {
	$result .= ", " if $result;
	$result .= $key;
	$result .= " ($list->{$key}->{'Rel'} $list->{$key}->{'Version'})"
	    if $list->{$key}->{'Rel'} && $list->{$key}->{'Version'};
    }
    return $result;
}

sub clean_db () {
    my %new_db;
    tie %new_db, 'MLDBM', db_filename( $conf->get('DISTRIBUTION') ) . ".new", GDBM_WRCREAT, 0664
	or die "FATAL: Cannot create new database\n";
    %new_db = %db;
    untie %db or die "FATAL: Cannot untie old database\n";
    system ("cp " . db_filename( $conf->get('DISTRIBUTION') ) . ".new " .
	    db_filename( $conf->get('DISTRIBUTION') ) ) == 0
	    or die "FATAL: Cannot overwrite old database";
    unlink db_filename( $conf->get('DISTRIBUTION') ) . ".new";
    %db = %new_db;
}

sub get_unsatisfied_dep ($$$$) {
    my $bd  = shift;
    my $pkgs = shift;
    my $dep = shift;
    my $savedep = shift;

    my $pkgname = $dep->{'Package'};

    if (defined $pkgs->{$pkgname}{'Provider'}) {
        # provides.  leave them for buildd/sbuild.
        return "";
    }

    # check cache
    return $pkgs->{$pkgname}{'Unsatisfied'} if $savedep and defined($pkgs->{$pkgname}{'Unsatisfied'});

    # Return unsatisfied deps to a higher caller to process
    if ((!defined($pkgs->{$pkgname})) or
        (defined($dep->{'Rel'}) and !version_compare( $pkgs->{$pkgname}{'Version'}, $dep->{'Rel'}, $dep->{'Version'} ) ) ) {
        my %deplist;
        $deplist{$pkgname} = $dep;
        my $deps = build_deplist(\%deplist);
        $pkgs->{$pkgname}{'Unsatisfied'} = $deps if $savedep;
        return $deps;
    }

    # set cache to "" to avoid infinite recursion
    $pkgs->{$pkgname}{'Unsatisfied'} = "" if $savedep;

    if (defined $pkgs->{$dep->{'Package'}}{'Depends'}) {
        my $deps = parse_deplist( $pkgs->{$dep->{'Package'}}{'Depends'} );
        foreach (keys %$deps) {
            $dep = $$deps{$_};
            # recur on dep.
            my $ret = get_unsatisfied_dep($bd,$pkgs,$dep,1);
            if ($ret ne "") {
                my $retdep = parse_deplist( $ret );
                foreach (keys %$retdep) {
                    $dep = $$retdep{$_};

                    $dep->{'Rel'} = '>=' if defined($dep->{'Rel'}) and $dep->{'Rel'} =~ '^=';

                    if (defined($dep->{'Rel'}) and $dep->{'Rel'} =~ '^>' and defined ($pkgs->{$dep->{'Package'}}) and
                        version_compare($bd->{$pkgs->{$dep->{'Package'}}{'Source'}}{'ver'},'>>',$pkgs->{$dep->{'Package'}}{'Sourcev'})) {
                        if (not defined($merge_binsrc{$dep->{'Package'}})) {
                            # the uninstallable package doesn't exist in the new source; look for something else that does.
                            delete $$retdep{$dep->{'Package'}};
                            foreach (sort (split( /\s*,\s*/, $bd->{$pkgs->{$dep->{'Package'}}{'Source'}}{'bin'}))) {
                                next if ($pkgs->{$_}{'all'} or not defined $pkgs->{$_}{'Version'});
                                $dep->{'Package'} = $_;
                                $dep->{'Rel'} = '>>';
                                $dep->{'Version'} = $pkgs->{$_}{'Version'};
                                $$retdep{$_} = $dep;
                                last;
                            }
                        }
                    } else {
                        # sanity check to make sure the depending binary still exists, and the depended binary exists and dep-wait on a new version of it
                        if ( defined($merge_binsrc{$pkgname}) and defined($pkgs->{$dep->{'Package'}}{'Version'}) ) {
                            delete $$retdep{$dep->{'Package'}};
                            $dep->{'Package'} = $pkgname;
                            $dep->{'Rel'} = '>>';
                            $dep->{'Version'} = $pkgs->{$pkgname}{'Version'};
                            $$retdep{$pkgname} = $dep;
                        }
                        delete $$retdep{$dep->{'Package'}} if (defined ($dep->{'Rel'}) and $dep->{'Rel'} =~ '^>');
                    }
                }
                $ret = build_deplist($retdep);
                $pkgs->{$pkgname}{'Unsatisfied'} = $ret if $savedep;
                return $ret;
            }
        }
    }
    return "";
}

sub auto_dep_wait ($$) {
    my $bd = shift;
    my $pkgs = shift;
    my $key;

    my $distribution = $conf->get('DISTRIBUTION');

    return if (defined ($conf->get('DB_DISTRIBUTIONS')->{'$distribution'}) &&
	       defined ($conf->get('DB_DISTRIBUTIONS')->{'$distribution'}->{'noadw'}));

    # We need to walk all of needs-build, as any new upload could make
    # something in needs-build have uninstallable deps
    foreach $key (keys %db) {
	my $pkg = $db{$key};
	next
	    if not defined $pkg or $pkg->{'State'} ne "Needs-Build";
	my $srcdeps = parse_srcdeplist($key,$bd->{$key}{'dep'},
				       $conf->get('ARCH'));
        foreach my $srcdep (@$srcdeps) {
            next if $srcdep->{'Neg'} != 0; # we ignore conflicts atm
            my $rc = get_unsatisfied_dep($bd,$pkgs,$srcdep,0);
            if ($rc ne "") {
                # set dep-wait
                my $deplist = parse_deplist( $pkg->{'Depends'} );
                my $newdeps = parse_deplist( $rc );
                my $change = 0;
                foreach (%$newdeps) {
                    my $dep = $$newdeps{$_};
                    # ensure we're not waiting on ourselves, or a package that has been removed
                    next if (not defined($merge_binsrc{$dep->{'Package'}})) or ($merge_binsrc{$dep->{'Package'}} eq $key);
                    if ($dep->{'Rel'} =~ '^>') {
                        $deplist->{$dep->{'Package'}} = $dep;
                        $change++;
                    }
                }
                if ($change) {
                    $pkg->{'Depends'} = build_deplist($deplist);
                    change_state( \$pkg, 'Dep-Wait' );
                    log_ta( $pkg, "--merge-all" );
                    $db{$key} = $pkg;
                    print "Auto-Dep-Waiting ${key}_$pkg->{'Version'} to $pkg->{'Depends'}\n" if $conf->get('VERBOSE');
                }
                last;
            }
	}
    }
}

sub pkg_version_eq ($$) {
    my $pkg = shift;
    my $version = shift;

    return 1
	if (defined $pkg->{'Binary-NMU-Version'}) and
	version_compare(binNMU_version($pkg->{'Version'},
				       $pkg->{'Binary-NMU-Version'}),'=', $version);
    return version_compare( $pkg->{'Version'}, "=", $version );
}
